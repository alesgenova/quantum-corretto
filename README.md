# Quantum Corretto Generator

## Overview
The script scans the source code and creates an internal map of all the files/modules/procedures/quantities defined in Quantum Espresso.

The goal is to convert each module into a datatype. The script already does most of the work, but some manual input is needed.

I have already generated a set of blueprints for each module in Quantum Espresso. You can find them in the folders `Modules/datatypes/` and `PW/src/datatypes/`.

A detailed explanation of the files is provided below for the `gvect` module.

## An Example (from `gvect` to the `gvect_type`)
The `gvect` module is defined in `Modules/recvec.f90`.

For the `gvect` module (and every other module), the script creates two files in the `Modules/datatypes/autogenerated/` directory.

The files are named `gvect_definition.f90` and `gvect_procedures.f90`, and contain the definition of the datatype and its procedures respectively.

Any file in the `autogenerated` directory can and will be overwritten at any time. When you modify a file first copy it into the `Modules/human/` folder.

### `gvect_definition.f90`
```fortran
type :: gvect_type
  logical :: is_alloc = .false.
  logical :: is_init = .false.
  integer :: ngm = 0
  integer :: ngm_g = 0
  integer :: ngl = 0
  integer :: ngmx = 0
  real(dp) :: ecutrho = 0.0_dp
  real(dp) :: gcutm = 0.0_dp
  integer, allocatable, dimension(:) :: nl
  integer, allocatable, dimension(:) :: nlm
  integer :: gstart = 2
  real(dp), allocatable, dimension(:) :: gg
  real(dp), dimension(:), pointer :: gl
  integer, allocatable, dimension(:) :: igtongl
  real(dp), allocatable, dimension(:,:) :: g
  integer, allocatable, dimension(:,:) :: mill
  integer, allocatable, dimension(:) :: ig_l2g
  integer, allocatable, dimension(:) :: sortedig_l2g
  integer, allocatable, dimension(:,:) :: mill_g
  complex(dp), allocatable, dimension(:,:) :: eigts1
  complex(dp), allocatable, dimension(:,:) :: eigts2
  complex(dp), allocatable, dimension(:,:) :: eigts3
  complex(dp), allocatable, dimension(:,:) :: eigts3
contains
  procedure, pass :: alloc
  procedure, pass :: init
  procedure, pass :: dealloc
end type gvect_type
```
Files with a `_definition` suffix such as this, should never be manually modified. If something is to be changed, notify me and I'll change it upstream in the script.

### `gvect_procedures.f90`
Files with a `_procedures` suffix are just blueprint, and are expected to be manually modified. I provide the scheleton to make it faster (esprecially the `alloc` method), but the actual logic has to be written by a human.

To modify a `*_procedures.f90` file, copy it to the `human` directory first (making sure you're not overwriting somebody else's work).
Any modification made directly in the `autogenerated` folder will be overwritten.
Every datatype is automatically given two bound methods, `alloc` and `init` (any suggestion on better names?)
`alloc` is where allocatable arrays defined in the datatype are allocated.
`init` is where the actual quantities are set.
If you want to add other procedures to the datatype, add them below, and also add the name of the procedure to the list in the first line (this is important to automate everything).

```fortran
['alloc', 'init']

subroutine alloc(this, n0)
  implicit none

  class(gvect_type), intent(inout) :: this
  integer, intent(in) :: n0

  integer :: istat

  if (this%is_alloc) return
  if (.not. allocated(nl)) allocate( nl(:), stat=istat )
  if (.not. allocated(nlm)) allocate( nlm(:), stat=istat )
  if (.not. allocated(gg)) allocate( gg(:), stat=istat )
  if (.not. allocated(igtongl)) allocate( igtongl(:), stat=istat )
  if (.not. allocated(g)) allocate( g(:,:), stat=istat )
  if (.not. allocated(mill)) allocate( mill(:,:), stat=istat )
  if (.not. allocated(ig_l2g)) allocate( ig_l2g(:), stat=istat )
  if (.not. allocated(sortedig_l2g)) allocate( sortedig_l2g(:), stat=istat )
  if (.not. allocated(mill_g)) allocate( mill_g(:,:), stat=istat )
  if (.not. allocated(eigts1)) allocate( eigts1(:,:), stat=istat )
  if (.not. allocated(eigts2)) allocate( eigts2(:,:), stat=istat )
  if (.not. allocated(eigts3)) allocate( eigts3(:,:), stat=istat )
  this%is_alloc = .true. return
end subroutine alloc

subroutine init(this)
  implicit none

  class(gvect_type), intent(inout) :: this
  if (this%is_init) return

  this%is_init = .true. return

end subroutine init
```

### `gvect_type.f90`
The actual `f90` that will be passed to the compiler will be an automatic combination of the autogenerated `gvect_definition.f90` and of the human-patched `gvect_procedures.f90`
The structure will be something like this:
```fortran
module gvect
implicit none

type :: gvect_type
  ...
contains
  procedure, pass :: alloc
  ...
end type gvect_type

contains

subroutine alloc(...)
  ...
end subroutine alloc
...
end module gvect
```

## An example of a problematic module (`scf_module`)
There are a handful of modules in the QE source that might pose a problem to our automatic approach.
They are those modules that already define a derived datatype. A good (non-trivial) example of such modules is `scf`.
For these types of modules my script will not be generating the definition and procedure blueprints, but it will instead include the name of the module into the file `*/datatypes/autogenerated/skip_modules.txt`.
This type of modules require extra care, and I propose the following approach: provide a partially sanitized version of the fortran file that contains the module that will override whatever original file came with the upstream source.
Lets look at the `scf` module:
```fortran
MODULE scf

  USE kinds,      ONLY : DP
  !
  USE ... ! basically all the quantities that souldn't be imported through use statements.
  !
  SAVE
  !
  TYPE scf_type
     REAL(DP),   ALLOCATABLE :: of_r(:,:)  ! the charge density in R-space
     COMPLEX(DP),ALLOCATABLE :: of_g(:,:)  ! the charge density in G-space
     REAL(DP),   ALLOCATABLE :: kin_r(:,:) ! the kinetic energy density in R-space
     COMPLEX(DP),ALLOCATABLE :: kin_g(:,:) ! the kinetic energy density in G-space
     REAL(DP),   ALLOCATABLE :: ns(:,:,:,:)! the LDA+U occupation matrix
     COMPLEX(DP),ALLOCATABLE :: ns_nc(:,:,:,:)!     ---       noncollinear case
     REAL(DP),   ALLOCATABLE :: bec(:,:,:) ! the PAW hamiltonian elements
  END TYPE scf_type
 
 TYPE mix_type
  COMPLEX(DP), ALLOCATABLE :: of_g(:,:)  ! the charge density in G-space
  COMPLEX(DP), ALLOCATABLE :: kin_g(:,:) ! the charge density in G-space
  REAL(DP),    ALLOCATABLE :: ns(:,:,:,:)! the LDA+U occupation matrix 
  COMPLEX(DP), ALLOCATABLE :: ns_nc(:,:,:,:)!     ---     noncollinear case 
  REAL(DP),    ALLOCATABLE :: bec(:,:,:) ! PAW corrections to hamiltonian
  REAL(DP)                 :: el_dipole  ! electrons dipole
 END TYPE mix_type

type (scf_type) :: rho  ! the charge density and its other components
type (scf_type) :: v    ! the scf potential
type (scf_type) :: vnew ! used to correct the forces

REAL(DP) :: v_of_0    ! vltot(G=0)      
REAL(DP), ALLOCATABLE :: vltot(:), vrs(:,:), rho_core(:), kedtau(:,:)
COMPLEX(DP), ALLOCATABLE :: rhog_core(:)

CONTAINS

... ! a series of terrible routines for allocation and whatnot.

```
The issue is that in this module we have both the definition of a datatype and a bunch of its instances.
On top of this, routines to allocate and initialize the datatype import all kind of crucial quantities from other modules.
Because of this, modules like this will be excluded from the automatic objectification procedure, and their name will be added to the `*/datatypes/autogenerated/skip_modules.txt` for an actual human to look at it.

### What should the Human do
In this specific case it would probably be advisable to blacklist the `scf_module.f90` file altogether, and instead provide one or more files that serve the purpose of the original blacklisted file, but that are in such a way that don't need to be patched (or can be patched automatically).

These files will be added to the source files pool of my script, and will be treated as if they came with the upstream version of QE.

#### Blacklisting a file
Add the name of the file you wish to blacklist to a new line in the `*/datatypes/human/skip_files.txt`.

#### Providing an additional / overriding file
Add as many `f90` files as you wish to the `*/datatypes/human/additional_files/` folder.

Files in this folder will be treated as if they came directly with the upstream source code.

It is understood that any file added this way will either:
  - need no patching
  - OR be patchable with the usual automatic procedure.



## Modules that shouldn't be objectified
By default the script generates a datatype for each and every module in Quantum Espresso.
If for whatever reason, turns out a module shouldn't undergo this transformation, please add its name to the `Modules/datatypes/human/exceptions.txt` or `PW/src/datatypes/human/exceptions.txt` files.

## Errors
Datatypes mimic the structure of the original modules. It is possible that some quantities (or even modules) have eluded my poorly written regular expressions. If you come across such cases, please notify it to me so I can fix the script upstream.
