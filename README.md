# Quantum Corretto Generator

## Overview
The script scans the source code and creates an internal map of all the files/modules/procedures/quantities defined in Quantum Espresso.

The goal is to convert each module into a datatype. The script already does most of the work, but some manual input is needed.

I have already generated a set of blueprints for each module in Quantum Espresso. You can find them in the folders `Modules/datatypes/` and `PW/src/datatypes/`.

Below I will be denoting relative paths with the wildcard `*`, which may stand for either `Modules/` or `PW/src/`.

I a providing two detailed examples:
- what to do for a standard module that can be objectified semi-automatically (e.g. `gvect`).
- what to do with a problematic module that requires more manual input (e.g. `scf`)


## A Straightforward Example (from `gvect` to the `gvect_type`)
The `gvect` module is defined in `Modules/recvec.f90`.

For the `gvect` module (and every other module), the script creates two files in the `*/datatypes/autogenerated/` directory.

The files are named `gvect_definition.f90` and `gvect_procedures.f90`, and contain the definition of the datatype and its procedures respectively.

Any file in the `autogenerated` directory can and will be overwritten at any time. When you modify a file first copy it into the `*/human/` folder.

### `gvect_definition.f90`
```fortran
type :: gvect_type
  logical :: is_alloc = .false.
  logical :: is_init = .false.
  integer :: ngm = 0
  integer :: ngm_g = 0
  integer :: ngl = 0
  integer :: ngmx = 0
  real(dp) :: ecutrho = 0.0_dp
  real(dp) :: gcutm = 0.0_dp
  integer, allocatable, dimension(:) :: nl
  integer, allocatable, dimension(:) :: nlm
  integer :: gstart = 2
  real(dp), allocatable, dimension(:) :: gg
  real(dp), dimension(:), pointer :: gl
  integer, allocatable, dimension(:) :: igtongl
  real(dp), allocatable, dimension(:,:) :: g
  integer, allocatable, dimension(:,:) :: mill
  integer, allocatable, dimension(:) :: ig_l2g
  integer, allocatable, dimension(:) :: sortedig_l2g
  integer, allocatable, dimension(:,:) :: mill_g
  complex(dp), allocatable, dimension(:,:) :: eigts1
  complex(dp), allocatable, dimension(:,:) :: eigts2
  complex(dp), allocatable, dimension(:,:) :: eigts3
  complex(dp), allocatable, dimension(:,:) :: eigts3
contains
  procedure, pass :: alloc
  procedure, pass :: init
  procedure, pass :: dealloc
end type gvect_type
```
Files with a `_definition` suffix such as this, should never be manually modified. If something is to be changed, notify me and I'll change it upstream in the script.

### `gvect_procedures.f90`
Files with a `_procedures` suffix are just blueprint, and are expected to be manually modified. I provide the scheleton to make it faster (esprecially the `alloc` method), but the actual logic has to be written by a human.

To modify a `*_procedures.f90` file, copy it to the `human` directory first (making sure you're not overwriting somebody else's work).
Any modification made directly in the `autogenerated` folder will be overwritten.

Every datatype is automatically given three bound methods, `alloc`, `init`, and `dealloc` (any suggestion on better names?):
- `alloc` is where allocatable arrays defined in the datatype are allocated.
- `init` is where the actual quantities are set.
- `dealloc` is where allocatable arrays defined in the datatype are deallocated.
 

If you want to add other procedures to the datatype, add them below, and also add the name of the procedure to the list in the first line (this is important to automate everything).

```fortran
['alloc', 'init', 'dealloc']

subroutine alloc(this, n0)
  use memory_manager_module, only: memory_manager

  implicit none

  class(gvect_type), intent(inout) :: this
  integer, intent(in) :: n0

  integer :: istat

  allocate( nl(:), stat=istat )
  call memory_manager('gvect%alloc', 'nl', nl(:), 1, istat)
  allocate( nlm(:), stat=istat )
  call memory_manager('gvect%alloc', 'nlm', nlm(:), 1, istat)
  allocate( gg(:), stat=istat )
  call memory_manager('gvect%alloc', 'gg', gg(:), 1, istat)
  allocate( igtongl(:), stat=istat )
  ...
  this%is_alloc = .true.
  return
end subroutine alloc

subroutine init(this)
  implicit none

  class(gvect_type), intent(inout) :: this

  this%is_init = .true.
  return
end subroutine init

subroutine dealloc(this)
  use memory_manager_module, only: memory_manager

  implicit none

  class(gvect_type), intent(inout) :: this
  integer :: istat

  deallocate( nl, stat=istat )
  call memory_manager('gvect%dealloc', 'nl', nl(:), -1, istat)
  deallocate( nlm, stat=istat )
  call memory_manager('gvect%dealloc', 'nlm', nlm(:), -1, istat)
  deallocate( gg, stat=istat )
  call memory_manager('gvect%dealloc', 'gg', gg(:), -1, istat)
  deallocate( igtongl, stat=istat )
  call memory_manager('gvect%dealloc', 'igtongl', igtongl(:), -1, istat)
  ...
  this%is_alloc = .false.
  return
end subroutine dealloc
```

### `gvect_type.f90`
The actual `f90` that will be passed to the compiler will be an automatic combination of the autogenerated `gvect_definition.f90` and of the human-patched `gvect_procedures.f90`
The structure will be something like this:
```fortran
module gvect
implicit none

type :: gvect_type
  ...
contains
  procedure, pass :: alloc
  ...
end type gvect_type

contains

subroutine alloc(...)
  ...
end subroutine alloc
...
end module gvect
```

## An example of a problematic module (`scf`)
There are a handful of modules in the QE source that might pose a problem to our automatic approach.

They are those modules that already define a derived datatype. A good (non-trivial) example of such modules is `scf`.

For these types of modules my script will not be generating the definition and procedure blueprints, but it will instead include the name of the module into the file `*/datatypes/autogenerated/skip_modules.txt`.

This type of modules require extra care, and I propose the following approach: provide a partially sanitized version of the fortran file that contains the module that will override whatever original file came with the upstream source.

Lets look at the `scf` module:
```fortran
MODULE scf
  USE kinds,      ONLY : DP
  !
  USE ... ! basically all the quantities that souldn't be imported through use statements.
  !
  SAVE
  !
  TYPE scf_type
    REAL(DP),   ALLOCATABLE :: of_r(:,:)
    COMPLEX(DP),ALLOCATABLE :: of_g(:,:)
    ...
  END TYPE scf_type
 
 TYPE mix_type
  COMPLEX(DP), ALLOCATABLE :: of_g(:,:)
  COMPLEX(DP), ALLOCATABLE :: kin_g(:,:)
  ...
 END TYPE mix_type

type (scf_type) :: rho
type (scf_type) :: v
type (scf_type) :: vnew

REAL(DP) :: v_of_0
REAL(DP), ALLOCATABLE :: vltot(:), vrs(:,:), rho_core(:), kedtau(:,:)
COMPLEX(DP), ALLOCATABLE :: rhog_core(:)

CONTAINS

... ! a series of terrible routines for allocation and whatnot.

```
The issue is that in this module we have both the definition of a datatype and a bunch of its instances.

On top of this, routines to allocate and initialize the datatype import all kind of crucial quantities from other modules.

Because of this, modules like this will be excluded from the automatic objectification procedure, and their name will be added to the `*/datatypes/autogenerated/skip_modules.txt` for an actual human to look at them.

### What should the Human do
In this specific case it would probably be advisable to blacklist the `scf_module.f90` file altogether, and instead provide one or more files that serve the purpose of the original blacklisted file, but that are in such a way that don't need to be patched (or can be patched automatically).

These files will be added to the source files pool of my script, and will be treated as if they came with the upstream version of QE.

## Blacklisting a file
Add the name of the file you wish to blacklist to a new line in the `*/datatypes/human/skip_files.txt`.

Any file that gets blacklisted will not be scanned by the script, and its modules/procedures won't be patched.

## Providing an additional / overriding file
Add as many `f90` files as you wish to the `*/datatypes/human/additional_files/` folder.

Files in this folder will be treated as if they came directly with the upstream source code.

It is understood that any file added this way will either:
  - need no patching
  - OR be patchable with the usual automatic procedure.


## Exclude modules from the objectification procedure
By default the script generates a datatype for each and every module in Quantum Espresso.

If for whatever reason, turns out a module shouldn't undergo this transformation, add its name to the `*/datatypes/human/skip_modules.txt` file.

This could be useful if the module only contains parameters and procedures, or if you want to blacklist a module without blacklisting the entire source file containing it (i.e. if there are other modules in the same file that you want to be included instead.)


## Mark an objectified module as completed
Whenever you complete the objectification of a module, add the name of the module to the `*/datatypes/human/completed_modules.txt` file.

## Errors
Datatypes mimic the structure of the original modules. It is possible that some quantities (or even modules) have eluded my poorly written regular expressions.

If you come across such cases, please notify it to me so I can fix the script upstream.
